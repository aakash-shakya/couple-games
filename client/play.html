<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playing LoverPlay!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
     <style>
        body { background: linear-gradient(135deg, #FFC0CB 0%, #C8A2C8 100%); }
         .cursive { font-family: 'Pacifico', cursive; }
         /* Simple fade-in animation */
        .fade-in {
            animation: fadeInAnimation 0.8s ease-in forwards;
            opacity: 0;
        }
        @keyframes fadeInAnimation {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-purple-900"
      x-data="playGame()">

    <div class="bg-white/90 p-6 md:p-10 rounded-xl shadow-2xl max-w-lg w-full text-center">
        <h1 class="cursive text-4xl text-pink-600 mb-4 drop-shadow">LoverPlay</h1>
        <p class="text-sm mb-1">Room Code: <strong x-text="roomCode"></strong></p>
        <p class="text-sm mb-4">You are Player <strong x-text="playerNumber || '...' "></strong></p>

        <div class="border-t border-b border-purple-200 py-6 my-6 min-h-[100px]">
            <h2 class="text-2xl font-semibold mb-3" x-text="turnStatus">Waiting for game...</h2>
            <!-- Ensure ID is present for animation trigger -->
            <div id="challenge-text" class="text-lg text-purple-800" x-html="currentChallenge || 'Waiting for the next challenge...'">
                <!-- Challenge text appears here -->
            </div>
        </div>

        <!-- Action Button (only shown when it's your turn) -->
        <template x-if="isMyTurn">
            <button @click="performAction"
                    :disabled="!isMyTurn"
                    class="w-full px-6 py-3 mt-4 bg-green-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-green-600 transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                Done! Next Challenge ðŸ‘‰
            </button>
        </template>

         <!-- Status Messages -->
        <p x-show="status" x-text="status" class="text-green-700 mt-4"></p>
        <p x-show="error" x-text="error" class="text-red-600 mt-4"></p>
        <p x-show="partnerStatus" x-text="partnerStatus" class="text-blue-600 mt-4 italic"></p>

    </div>

     <footer class="mt-8 text-white text-sm opacity-75">
        <a href="/" class="hover:text-pink-200 transition">Leave Game</a>
    </footer>

    <script>
        function playGame() {
            return {
                socket: null,
                roomCode: '',
                playerNumber: null, // Will be set by server
                gameType: null,
                currentChallenge: '',
                isMyTurn: false,
                turnStatus: 'Connecting...',
                status: '',
                error: '',
                partnerStatus: '', // Messages like 'Partner left', 'Partner completed task'

                init() {
                    // Extract room code from URL path
                    const pathSegments = window.location.pathname.split('/');
                    this.roomCode = pathSegments[pathSegments.length - 1];

                    if (!this.roomCode) {
                        this.error = "No room code specified!";
                        // Redirect or show error prominently
                        // window.location.href = '/'; // Example redirect
                        return;
                    }

                    this.socket = io();

                    this.socket.on('connect', () => {
                        console.log('Connected to game server');
                        this.turnStatus = 'Connected. Waiting for game start...';
                        this.error = ''; // Clear connection error on successful connect
                        // Emit joinRoom event to join the room on connection
                        if (this.roomCode) {
                            this.socket.emit('joinRoom', { roomCode: this.roomCode });
                        } else {
                            this.error = 'No room code specified in URL.';
                        }
                    });

                    // Listen for join confirmation
                    this.socket.on('joined', ({ roomCode, playerNumber }) => {
                        console.log(`Joined room: ${roomCode}, you are Player ${playerNumber}`);
                        this.roomCode = roomCode;
                        // Only set playerNumber if not already set to avoid overwriting
                        if (!this.playerNumber) {
                            this.playerNumber = playerNumber;
                        }
                        this.socket.emit('getPlayerNumber', { roomCode: this.roomCode });
                    });

                    this.socket.on('playerNumberInfo', ({ number }) => {
                        if (number) {
                            // Only update playerNumber if not already set or different
                            if (!this.playerNumber || this.playerNumber !== number) {
                                this.playerNumber = number;
                                console.log(`Confirmed as Player ${this.playerNumber}`);
                            }
                            // Update status if waiting for player number
                            if (this.turnStatus.includes('Connecting') || this.turnStatus.includes('Waiting for player')) {
                                this.turnStatus = 'Waiting for game start...';
                            }
                        } else {
                            // Handle case where server doesn't know this socket in this room
                            console.error("Could not verify player status for room:", this.roomCode);
                            this.error = "Could not verify player status. Try rejoining the room.";
                            this.turnStatus = 'Error';
                            // Maybe redirect: window.location.href = '/join.html';
                        }
                    });

                    // Remove roomCreated handler since play.html does not create rooms

                     this.socket.on('playerNumberInfo', ({ number }) => {
                         if (number) {
                            this.playerNumber = number;
                            console.log(`Confirmed as Player ${this.playerNumber}`);
                            // Update status if waiting for player number
                            if (this.turnStatus.includes('Connecting') || this.turnStatus.includes('Waiting for player')) {
                                this.turnStatus = 'Waiting for game start...';
                            }
                         } else {
                             // Handle case where server doesn't know this socket in this room
                             console.error("Could not verify player status for room:", this.roomCode);
                             this.error = "Could not verify player status. Try rejoining the room.";
                             this.turnStatus = 'Error';
                             // Maybe redirect: window.location.href = '/join.html';
                         }
                     });

                    // Listen for game readiness (both players joined)
                    this.socket.on('gameReady', ({ roomCode }) => {
                        console.log(`Room ${roomCode} is ready.`);
                        if (this.playerNumber === 1) {
                            this.turnStatus = 'Room ready! Waiting for you (Player 1) to start the game.';
                            // Optionally show a start button here if not already present
                        } else {
                            this.turnStatus = 'Room ready! Waiting for Player 1 to start the game.';
                        }
                    });

                    this.socket.on('gameStarted', ({ gameType }) => {
                        console.log(`Game started: ${gameType}`);
                        this.gameType = gameType;
                        this.status = `Game started: ${gameType}!`;
                        this.error = '';
                        this.partnerStatus = '';
                        // Initial turn status will be set by 'yourTurn' or 'opponentTurn'
                    });

                    this.socket.on('yourTurn', ({ challenge }) => {
                        try {
                            console.log('My turn:', challenge);
                            this.currentChallenge = this.formatChallenge(challenge);
                            this.isMyTurn = true;
                            this.turnStatus = "ðŸ’– Your Turn! ðŸ’–";
                            this.status = ''; // Clear previous status
                            this.error = '';
                            this.partnerStatus = ''; // Clear partner status
                            this.triggerFadeIn(); // Trigger animation
                        } catch (error) {
                            console.error('Error processing yourTurn challenge:', error);
                            this.error = 'Error processing challenge.';
                        }
                    });

                    this.socket.on('opponentTurn', ({ challenge }) => {
                        try {
                            console.log("Opponent's turn:", challenge);
                            this.currentChallenge = this.formatChallenge(challenge);
                            this.isMyTurn = false;
                            this.turnStatus = "Partner's Turn... ðŸ¤”";
                            this.status = '';
                            this.error = '';
                            // Don't clear partnerStatus here, it might have just been set by opponentAction
                            this.triggerFadeIn(); // Trigger animation
                        } catch (error) {
                            console.error('Error processing opponentTurn challenge:', error);
                            this.error = 'Error processing challenge.';
                        }
                    });

                     this.socket.on('opponentAction', ({ action }) => {
                        console.log('Opponent action:', action);
                        // Display feedback that partner acted
                        this.partnerStatus = `Partner completed the task! âœ¨ Waiting for your turn...`;
                        // Clear after a few seconds
                        setTimeout(() => {
                            // Only clear if it hasn't been replaced by a new turn message
                            if (this.partnerStatus === `Partner completed the task! âœ¨ Waiting for your turn...`) {
                                this.partnerStatus = '';
                            }
                        }, 4000);
                    });


                    this.socket.on('playerLeft', ({ message }) => {
                        console.log('Partner left:', message);
                        this.error = message;
                        this.turnStatus = 'Game Over';
                        this.isMyTurn = false;
                        this.currentChallenge = 'Your partner has left the room. ðŸ˜¢';
                        this.triggerFadeIn(); // Show the message
                    });

                    this.socket.on('error', ({ message }) => {
                        console.error('Game error:', message);
                        this.error = message;
                        // Optionally change turnStatus based on error severity
                        // e.g., if (message.includes('Failed to generate')) this.turnStatus = 'Error generating challenge';
                    });

                    this.socket.on('disconnect', (reason) => {
                        console.log('Disconnected from server:', reason);
                        this.error = 'Connection lost. Attempting to reconnect...';
                        this.turnStatus = 'Disconnected';
                        this.isMyTurn = false; // Cannot act while disconnected
                        // Alpine.js will automatically try to reconnect via Socket.IO client library
                    });

                    this.socket.on('error', (error) => {
                        console.error('Socket error:', error);
                    });

                    this.socket.io.on('reconnect_attempt', (attempt) => {
                        console.log(`Reconnection attempt #${attempt}`);
                    });

                    this.socket.io.on('reconnect_failed', () => {
                        console.error('Reconnection failed');
                    });

                    this.socket.io.on('reconnect_error', (error) => {
                        console.error('Reconnection error:', error);
                    });
                },

                performAction() {
                    if (!this.isMyTurn) return;
                    console.log('Performing action (completed challenge)');
                    this.status = 'Sending confirmation...';
                    this.error = ''; // Clear previous errors
                    this.socket.emit('playerAction', { action: 'completed' });
                    this.isMyTurn = false; // Visually disable button immediately
                    this.turnStatus = "Waiting for next challenge..."; // Optimistic update
                },

                formatChallenge(text) {
                    if (!text) return 'Waiting...';
                    // Basic formatting: replace newlines with <br> for display
                    // Also escape HTML to prevent potential injection if AI includes tags
                    const escapedText = text.replace(/</g, "<").replace(/>/g, ">");
                    return escapedText.replace(/\n/g, '<br>');
                },

                triggerFadeIn() {
                    // Re-trigger fade-in animation for the challenge text
                    const el = document.getElementById('challenge-text');
                    if (el) {
                        el.classList.remove('fade-in');
                        // void el.offsetWidth; // Force reflow - sometimes needed, sometimes not. Modern browsers are good.
                        // Using requestAnimationFrame is generally safer for timing.
                        requestAnimationFrame(() => {
                             el.classList.add('fade-in');
                        });
                    }
                }
            }
        }
    </script>

</body>
</html>
