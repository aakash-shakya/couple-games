<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playing LoverPlay!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
    <style>
        body { background: linear-gradient(135deg, #FFC0CB 0%, #C8A2C8 100%); }
        .cursive { font-family: 'Pacifico', cursive; }
        /* Simple fade-in animation */
        .fade-in {
            animation: fadeInAnimation 0.8s ease-in forwards;
            opacity: 0;
        }
        @keyframes fadeInAnimation {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-purple-900"
      x-data="playGame()">

    <div class="bg-white/90 p-6 md:p-10 rounded-xl shadow-2xl max-w-lg w-full text-center">
        <h1 class="cursive text-4xl text-pink-600 mb-4 drop-shadow">LoverPlay</h1>
        <p class="text-sm mb-1">Room Code: <strong x-text="roomCode"></strong></p>
        <p class="text-sm mb-4">You are Player <strong x-text="playerNumber || '...' "></strong></p>

        <div class="border-t border-b border-purple-200 py-6 my-6 min-h-[100px]">
            <h2 class="text-2xl font-semibold mb-3" x-text="turnStatus">Connecting...</h2>
            <div id="challenge-text" class="text-lg text-purple-800" x-html="currentChallenge || 'Waiting for the game to start...'">
                <!-- Challenge text appears here -->
            </div>
        </div>

        <template x-if="isMyTurn">
            <button @click="performAction"
                    :disabled="!isMyTurn || actionInProgress"
                    class="w-full px-6 py-3 mt-4 bg-green-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-green-600 transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                <span x-show="!actionInProgress">Done! Next Challenge ðŸ‘‰</span>
                <span x-show="actionInProgress">Sending...</span>
            </button>
        </template>

        <p x-show="status" x-text="status" class="text-green-700 mt-4"></p>
        <p x-show="error" x-text="error" class="text-red-600 mt-4"></p>
        <p x-show="partnerStatus" x-text="partnerStatus" class="text-blue-600 mt-4 italic"></p>
    </div>

    <footer class="mt-8 text-white text-sm opacity-75">
        <a href="/" class="hover:text-pink-200 transition">Leave Game</a>
    </footer>

    <script>
        function playGame() {
            return {
                socket: null,
                roomCode: '',
                playerNumber: null,
                gameType: null,
                currentChallenge: '',
                isMyTurn: false,
                turnStatus: 'Initializing...',
                status: '',
                error: '',
                partnerStatus: '',
                actionInProgress: false, // Prevent double clicks

                init() {
                    const pathSegments = window.location.pathname.split('/');
                    this.roomCode = pathSegments[pathSegments.length - 1]?.toUpperCase(); // Ensure uppercase

                    if (!this.roomCode) {
                        this.error = "No room code found in URL!";
                        this.turnStatus = 'Error';
                        return;
                    }

                    this.turnStatus = 'Connecting to game...';
                    this.socket = io();

                    this.socket.on('connect', () => {
                        console.log('Connected to game server with socket ID:', this.socket.id);
                        this.status = 'Connected. Joining room...';
                        this.error = '';
                        // IMPORTANT: Emit 'joinGameRoom' (or a similar distinct event)
                        // to signal this is the play screen joining, not the initial join.
                        // The server needs to handle this event specifically to update the socket ID.
                        this.socket.emit('joinGameRoom', { roomCode: this.roomCode });
                    });

                    // Listen for an event confirming the player is correctly associated in the game room
                    // The server should send this after handling 'joinGameRoom'
                    this.socket.on('gameJoined', ({ playerNumber, gameState }) => {
                        console.log(`Successfully joined game room ${this.roomCode} as Player ${playerNumber}. Current state:`, gameState);
                        this.playerNumber = playerNumber;
                        this.gameType = gameState.gameType;
                        this.status = `Joined Game: ${this.gameType || 'Unknown Type'}`;
                        this.error = '';

                        // Update UI based on the received game state
                        this.updateGameState(gameState);
                    });

                    // Consolidated event for game state updates (turn changes, new challenges)
                    this.socket.on('gameStateUpdate', (gameState) => {
                        console.log('Received game state update:', gameState);
                        this.updateGameState(gameState);
                        this.triggerFadeIn(); // Add fade-in for new challenges
                    });


                    // Simplified opponent action notification
                    this.socket.on('opponentActionCompleted', () => {
                        console.log('Opponent completed their turn.');
                        this.partnerStatus = `Partner completed the task! âœ¨`;
                        // No need to automatically clear, gameStateUpdate will change the status text
                    });

                    this.socket.on('playerLeft', ({ message }) => {
                        console.log('Partner left:', message);
                        this.error = message || 'Your partner has left the room. ðŸ˜¢';
                        this.turnStatus = 'Game Over';
                        this.isMyTurn = false;
                        this.currentChallenge = '';
                        this.partnerStatus = '';
                        this.triggerFadeIn();
                    });

                    this.socket.on('error', ({ message }) => {
                        console.error('Game error:', message);
                        // Avoid overwriting critical errors like playerLeft
                        if (!this.error || !this.error.includes('left')) {
                            this.error = message;
                        }
                        // Consider more specific error handling if needed
                        if (message.includes('Room not found') || message.includes('Could not join')) {
                             this.turnStatus = 'Error joining room';
                             this.currentChallenge = 'Could not connect to the game. Please try going back and joining again.';
                        }
                    });

                    this.socket.on('disconnect', (reason) => {
                        console.log('Disconnected from server:', reason);
                        // Only show reconnecting message if the game wasn't already over
                        if (this.turnStatus !== 'Game Over') {
                            this.error = `Connection lost (${reason}). Attempting to reconnect...`;
                            this.turnStatus = 'Reconnecting...';
                            this.isMyTurn = false;
                            this.partnerStatus = '';
                        }
                    });

                     // Optional: Handle reconnection logic if needed
                    this.socket.on('reconnect', (attemptNumber) => {
                        console.log(`Reconnected after ${attemptNumber} attempts.`);
                        this.turnStatus = 'Reconnected. Resuming game...';
                        this.error = '';
                        // Re-emit joinGameRoom to ensure server has the correct socket ID
                        this.socket.emit('joinGameRoom', { roomCode: this.roomCode });
                    });

                    // Optional: More detailed reconnect listeners if debugging is needed
                    // this.socket.io.on('reconnect_attempt', (attempt) => {
                    //     console.log(`Reconnection attempt #${attempt}`);
                    // });
                    // this.socket.io.on('reconnect_failed', () => {
                    //     console.error('Reconnection failed permanently.');
                    //     this.error = 'Could not reconnect to the server. Please refresh.';
                    //     this.turnStatus = 'Disconnected';
                    // });
                    // this.socket.io.on('reconnect_error', (error) => {
                    //     console.error('Reconnection error:', error);
                    //     this.error = 'Error during reconnection attempt.';
                    // });
                },

                updateGameState(gameState) {
                    this.currentChallenge = this.formatChallenge(gameState.currentChallenge);
                    this.gameType = gameState.gameType; // Ensure gameType is updated

                    if (gameState.currentPlayer === this.playerNumber) {
                        this.isMyTurn = true;
                        this.turnStatus = "ðŸ’– Your Turn! ðŸ’–";
                        this.partnerStatus = ''; // Clear partner status on your turn
                    } else {
                        this.isMyTurn = false;
                        // Only show partner's turn if game isn't over and challenge exists
                        if (this.turnStatus !== 'Game Over' && gameState.currentChallenge) {
                             this.turnStatus = "Partner's Turn... ðŸ¤”";
                        } else if (!gameState.currentChallenge && this.turnStatus !== 'Game Over') {
                            this.turnStatus = 'Waiting for next challenge...';
                        }
                    }
                     // Reset action flag when state updates
                    this.actionInProgress = false;
                    // Clear generic status messages when game state is known
                    this.status = '';
                },

                performAction() {
                    if (!this.isMyTurn || this.actionInProgress) return;

                    console.log('Performing action (completed challenge)');
                    this.actionInProgress = true; // Set flag
                    this.status = ''; // Clear previous status
                    this.error = '';
                    this.partnerStatus = '';
                    // Emit an event indicating the current player finished their turn
                    this.socket.emit('completeTurn', { roomCode: this.roomCode });

                    // Optimistically update UI, server confirmation will follow via gameStateUpdate
                    this.isMyTurn = false;
                    this.turnStatus = "Waiting for next challenge...";
                },

                formatChallenge(text) {
                    if (!text) return 'Waiting for the next challenge...';
                    // Basic escaping and formatting
                    let escaped = text.replace(/&/g, '&amp;')
                                      .replace(/</g, '&lt;')
                                      .replace(/>/g, '&gt;')
                                      .replace(/"/g, '&quot;')
                                      .replace(/'/g, '&#039;');
                    // Bold formatting
                    escaped = escaped.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                     // Newline formatting
                    return escaped.replace(/\n/g, '<br>');
                },

                triggerFadeIn() {
                    this.$nextTick(() => { // Ensure DOM is updated before manipulating class
                        const el = document.getElementById('challenge-text');
                        if (el) {
                            el.classList.remove('fade-in');
                            // Force reflow/repaint before adding class again
                            void el.offsetWidth;
                            el.classList.add('fade-in');
                        }
                    });
                }
            }
        }
    </script>
</body>
</html>
