<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playing LoverPlay!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
    <style>
        body { background: linear-gradient(135deg, #FFC0CB 0%, #C8A2C8 100%); }
        .cursive { font-family: 'Pacifico', cursive; }
        .fade-in { animation: fadeInAnimation 0.8s ease-in forwards; opacity: 0; }
        @keyframes fadeInAnimation { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .video-container { display: flex; flex-wrap: wrap; justify-content: space-around; margin-bottom: 1rem; gap: 1rem; }
        .video-box { background-color: rgba(0,0,0,0.1); border-radius: 0.5rem; overflow: hidden; width: 100%; max-width: 320px; aspect-ratio: 4 / 3; position: relative; }
        @media (min-width: 640px) { .video-box { width: 48%; } }
        .video-box video { display: block; width: 100%; height: 100%; object-fit: cover; }
        .video-label { position: absolute; top: 4px; left: 6px; background: rgba(0,0,0,0.1); color: white; padding: 2px 6px; font-size: 0.75rem; border-radius: 4px; }
        .video-box#localVideoContainer:not(.active) { display: none; }
        .remote-placeholder { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background-color: rgba(200, 200, 200, 0.5); color: #555; text-align: center; padding: 1rem; }
        .pulse { animation: pulseAnimation 1.5s infinite; }
        @keyframes pulseAnimation { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .reaction-container { display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem; }
        .reaction-btn { font-size: 1.5rem; cursor: pointer; transition: transform 0.2s; }
        .reaction-btn:hover { transform: scale(1.2); }
        .reaction-animation { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4rem; animation: reactionPop 3s ease-out forwards; pointer-events: none; z-index: 3000; }
        @keyframes reactionPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-purple-900" x-data="playGame()">
    <div class="bg-white/90 p-6 md:p-10 rounded-xl shadow-2xl max-w-3xl w-full text-center">
        <h1 class="cursive text-4xl text-pink-600 mb-4 drop-shadow">LoverPlay</h1>
        <p class="text-sm mb-1">Room Code: <strong x-text="roomCode"></strong></p>
        <p class="text-sm mb-4">You are Player <strong x-text="playerNumber || '...' "></strong></p>
        <div class="video-container">
            <div id="localVideoContainer" class="video-box" :class="{ 'active': webcamActive }">
                <video id="localVideo" autoplay muted playsinline></video>
                <span class="video-label">You</span>
            </div>
            <div class="video-box active">
                <video id="remoteVideo" autoplay playsinline></video>
                <span class="video-label">Partner</span>
                <div x-show="!partnerWebcamActive" class="remote-placeholder">
                    Partner's video off
                </div>
            </div>
        </div>
        <button @click="toggleWebcam"
                class="mb-4 px-4 py-2 text-sm rounded-full transition duration-300"
                :class="webcamActive ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-blue-500 hover:bg-blue-600 text-white'">
            <span x-show="!webcamActive">üì∑ Start Webcam</span>
            <span x-show="webcamActive">üö´ Stop Webcam</span>
        </button>
        <div class="border-t border-b border-purple-200 py-6 my-6 min-h-[100px]">
            <h2 class="text-2xl font-semibold mb-3" x-text="turnStatus">Connecting...</h2>
            <div id="challenge-text" class="text-lg text-purple-800 fade-in" x-html="currentChallenge"></div>
        </div>
        <div class="mt-4 mb-6">
            <template x-if="receivedTextAnswer">
                <div class="mb-4 p-3 bg-purple-100 border border-purple-200 rounded-lg text-left ">
                    <strong>Partner wrote:</strong>
                    <p x-text="receivedTextAnswer" class="mt-1 whitespace-pre-wrap italic"></p>
                    <div class="reaction-container">
                        <span class="reaction-btn" @click="sendReaction('‚ù§Ô∏è')">‚ù§Ô∏è</span>
                        <span class="reaction-btn" @click="sendReaction('ü•∞')">ü•∞</span>
                        <span class="reaction-btn" @click="sendReaction('üòç')">üòç</span>
                        <span class="reaction-btn" @click="sendReaction('üëÖ')">üëÖ</span>
                        <span class="reaction-btn" @click="sendReaction('üòà')">üòà</span>
                        <span class="reaction-btn" @click="sendReaction('ü´¶')">ü´¶</span>
                        <span class="reaction-btn" @click="sendReaction('üçÜ')">üçÜ</span>
                        <span class="reaction-btn" @click="sendReaction('üí¶')">üí¶</span>
                        <span class="reaction-btn" @click="sendReaction('üçë')">üçë</span>
                    </div>
                </div>
            </template>
            <template x-if="receivedReaction">
                <div class="reaction-animation" x-text="receivedReaction" x-effect="setTimeout(() => { receivedReaction = ''; }, 1200)"></div>
            </template>
            <template x-if="isMyTurn">
                <textarea id="textAnswer" x-model="textAnswer"
                          :disabled="webcamActive"
                          rows="3"
                          class="w-full p-3 border border-purple-300 rounded-lg focus:ring-2 focus:ring-pink-400 focus:border-transparent disabled:bg-gray-200 disabled:cursor-not-allowed"
                          :placeholder="webcamActive ? 'Webcam is active, speak or perform!' : 'Type your answer here...'"></textarea>
            </template>
        </div>
        <template x-if="isMyTurn">
            <button @click="performAction"
                    :disabled="actionInProgress"
                    class="w-full px-6 py-3 mt-4 bg-green-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-green-600 transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                <span x-show="!actionInProgress">Done! Next Challenge üëâ</span>
                <span x-show="actionInProgress">Sending...</span>
            </button>
        </template>
        <p x-show="status" x-text="status" class="text-green-700 mt-4"></p>
        <p x-show="error" x-text="error" class="text-red-600 mt-4"></p>
        <p x-show="partnerStatus" x-text="partnerStatus" class="text-blue-600 mt-4 italic"></p>
    </div>
    <footer class="mt-8 text-white text-sm opacity-75">
        <a href="/" class="hover:text-pink-200 transition">Leave Game</a>
    </footer>
    <script>
        function playGame() {
            return {
                socket: null,
                roomCode: '',
                playerNumber: null,
                gameType: null,
                currentChallenge: 'Waiting for the game to start...',
                isMyTurn: false,
                turnStatus: 'Initializing...',
                status: '',
                error: '',
                partnerStatus: '',
                actionInProgress: false,
                webcamActive: false,
                localStream: null,
                partnerWebcamActive: false,
                textAnswer: '',
                receivedTextAnswer: '',
                receivedReaction: '',
                peerConnection: null,
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                ],
                localTrackSenders: [],
                negotiationPending: false,
                reconnectTimeout: null,

                init() {
                    const pathSegments = window.location.pathname.split('/');
                    this.roomCode = pathSegments[pathSegments.length - 1]?.toUpperCase();
                    if (!this.roomCode) {
                        this.error = "No room code found in URL!";
                        this.turnStatus = 'Error';
                        return;
                    }
                    this.turnStatus = 'Connecting to game...';
                    this.socket = io();
                    this.setupSocketListeners();
                },

                setupSocketListeners() {
                    this.socket.on('connect', () => {
                        console.log('Connected to game server with socket ID:', this.socket.id);
                        this.status = 'Connected. Joining room...';
                        this.error = '';
                        this.socket.emit('joinGameRoom', { roomCode: this.roomCode });
                    });

                    this.socket.on('gameJoined', ({ playerNumber, gameState }) => {
                        console.log(`Successfully joined game room ${this.roomCode} as Player ${playerNumber}. Initial state received.`);
                        this.playerNumber = playerNumber;
                        this.updateGameState(gameState);
                        this.status = `Joined Game: ${this.gameType || 'Unknown Type'}`;
                        this.error = '';
                    });

                    this.socket.on('gameStateUpdate', (gameState) => {
                        console.log('Received game state update:', JSON.stringify(gameState));
                        this.updateGameState(gameState);
                        this.triggerFadeIn();
                        this.receivedTextAnswer = '';
                        if (!this.isMyTurn) {
                            this.textAnswer = '';
                        }
                    });

                    this.socket.on('receiveTextAnswer', (answer) => {
                        console.log('Received text answer:', answer);
                        this.receivedTextAnswer = answer;
                    });

                    this.socket.on('receiveReaction', (reaction) => {
                        console.log('Received reaction:', reaction, 'for Player', this.playerNumber);
                        this.receivedReaction = reaction;
                        this.$nextTick(() => {
                            console.log('Displaying reaction:', reaction, 'in UI for Player', this.playerNumber);
                            const reactionElement = document.querySelector('.reaction-animation');
                            if (reactionElement) {
                                console.log('Reaction element found, animation should be visible');
                            } else {
                                console.warn('Reaction element not found in DOM');
                            }
                            setTimeout(() => {
                                console.log('Clearing reaction:', reaction);
                                this.receivedReaction = '';
                            }, 1200);
                        });
                    });

                    this.socket.on('partnerWebcamStatus', (status) => {
                        console.log('Partner webcam status changed:', status);
                        this.partnerWebcamActive = status.active;
                        if (!status.active) {
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo && remoteVideo.srcObject) {
                                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                                remoteVideo.srcObject = null;
                                console.log('Cleared remote video stream due to partner stopping webcam.');
                            }
                        }
                    });

                    this.socket.on('offer', async ({ sdp }) => {
                        console.log('Received offer');
                        if (!this.peerConnection) {
                            this.initPeerConnection();
                        }
                        try {
                            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
                            console.log('Remote description (offer) set.');

                            if (this.localStream) {
                                const existingSenders = this.peerConnection.getSenders().map(sender => sender.track?.id);
                                this.localTrackSenders = [];
                                this.localStream.getTracks().forEach(track => {
                                    if (!existingSenders.includes(track.id)) {
                                        try {
                                            this.localTrackSenders.push(this.peerConnection.addTrack(track, this.localStream));
                                            console.log('Added local track on receiving offer:', track.kind, 'enabled:', track.enabled);
                                        } catch (err) {
                                            console.error('Error adding track on offer:', err);
                                        }
                                    } else {
                                        console.log('Skipped adding track; sender already exists for track ID:', track.id);
                                    }
                                });
                            }

                            const answer = await this.peerConnection.createAnswer();
                            await this.peerConnection.setLocalDescription(answer);
                            console.log('Local description (answer) set. Sending answer.');
                            this.socket.emit('answer', { sdp: answer });
                        } catch (err) {
                            console.error('Error handling offer:', err);
                            this.error = 'Failed to process video call offer.';
                        }
                    });

                    this.socket.on('answer', async ({ sdp }) => {
                        console.log('Received answer');
                        if (!this.peerConnection) {
                            console.error('Received answer but no peer connection exists!');
                            return;
                        }
                        try {
                            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
                            console.log('Remote description (answer) set.');
                            if (this.negotiationPending) {
                                this.negotiationPending = false;
                                await this.createOffer();
                            }
                        } catch (err) {
                            console.error('Error handling answer:', err);
                            this.error = 'Failed to process video call answer.';
                        }
                    });

                    this.socket.on('iceCandidate', async ({ candidate }) => {
                        console.log('Received ICE candidate');
                        if (!this.peerConnection) {
                            console.warn('Received ICE candidate but no peer connection exists yet.');
                            return;
                        }
                        try {
                            if (candidate) {
                                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                console.log('Added ICE candidate.');
                            }
                        } catch (err) {
                            if (!err.message.includes("remote description is not set")) {
                                console.error('Error adding ICE candidate:', err);
                            }
                        }
                    });

                    this.socket.on('opponentActionCompleted', () => {
                        console.log('Opponent completed their turn.');
                        this.partnerStatus = `Partner completed the task! ‚ú®`;
                    });

                    this.socket.on('playerLeft', ({ message, disconnectedPlayerNumber }) => {
                        console.log(`Player ${disconnectedPlayerNumber} left:`, message);
                        this.reconnectTimeout = setTimeout(() => {
                            this.error = message || `Player ${disconnectedPlayerNumber} has left the room. üò¢`;
                            this.turnStatus = 'Game Over';
                            this.isMyTurn = false;
                            this.partnerWebcamActive = false;
                            this.stopWebcam();
                            if (this.peerConnection) {
                                this.peerConnection.close();
                                this.peerConnection = null;
                                console.log('Peer connection closed due to player leaving.');
                            }
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo) remoteVideo.srcObject = null;
                        }, 5000);
                    });

                    this.socket.on('playerRejoined', ({ playerNumber }) => {
                        console.log(`Player ${playerNumber} rejoined the room.`);
                        if (this.reconnectTimeout) {
                            clearTimeout(this.reconnectTimeout);
                            this.reconnectTimeout = null;
                        }
                        this.error = '';
                        this.turnStatus = this.isMyTurn ? 'üíñ Your Turn! üíñ' : 'Partner\'s Turn... ü§î';
                        this.status = `Player ${playerNumber} rejoined!`;
                        if (this.webcamActive) {
                            this.stopWebcam();
                            this.startWebcam();
                        }
                    });

                    this.socket.on('error', ({ message }) => {
                        console.error('Game error:', message);
                        if (!this.error || !this.error.includes('left')) {
                            this.error = message;
                        }
                        if (message.includes('Room not found') || message.includes('Could not assign')) {
                            this.turnStatus = 'Error joining room';
                            this.currentChallenge = 'Could not connect to the game. Please try going back and joining again.';
                            this.isMyTurn = false;
                        }
                    });

                    this.socket.on('disconnect', (reason) => {
                        console.log('Disconnected from server:', reason);
                        if (this.turnStatus !== 'Game Over') {
                            this.error = `Connection lost (${reason}). Please refresh the page if it doesn't reconnect.`;
                            this.turnStatus = 'Connection Lost';
                            this.isMyTurn = false;
                            this.partnerStatus = '';
                            this.partnerWebcamActive = false;
                            this.stopWebcam();
                        }
                    });

                    this.socket.io.on('reconnect', (attemptNumber) => {
                        console.log(`Reconnected after ${attemptNumber} attempts.`);
                        this.turnStatus = 'Reconnected. Re-joining game...';
                        this.error = '';
                        this.socket.emit('joinGameRoom', { roomCode: this.roomCode });
                        this.status = 'Reconnected. Please restart your webcam if needed.';
                    });
                },

                initPeerConnection() {
                    console.log('Initializing Peer Connection...');
                    if (this.peerConnection) {
                        console.log('Closing existing peer connection before re-initializing.');
                        this.peerConnection.close();
                        this.peerConnection = null;
                    }
                    this.localTrackSenders = [];
                    this.negotiationPending = false;

                    try {
                        this.peerConnection = new RTCPeerConnection({ iceServers: this.iceServers });

                        this.peerConnection.onicecandidate = (event) => {
                            if (event.candidate) {
                                console.log('Generated ICE candidate, sending...');
                                this.socket.emit('iceCandidate', { candidate: event.candidate });
                            } else {
                                console.log('All ICE candidates have been sent.');
                            }
                        };

                        this.peerConnection.ontrack = (event) => {
                            console.log('Received remote track:', event.track.kind, 'enabled:', event.track.enabled);
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo && event.streams && event.streams[0]) {
                                remoteVideo.srcObject = event.streams[0];
                                remoteVideo.muted = false;
                                remoteVideo.volume = 1.0;
                                this.partnerWebcamActive = true;
                                console.log('Assigned remote stream to video element.');
                                const audioTracks = event.streams[0].getAudioTracks();
                                console.log('Remote stream audio tracks:', audioTracks.map(t => ({ id: t.id, enabled: t.enabled, muted: t.muted })));
                            } else {
                                console.warn('Could not assign remote track to video element.');
                            }
                        };

                        this.peerConnection.onnegotiationneeded = async () => {
                            if (this.negotiationPending) {
                                console.log('Negotiation already pending, queuing...');
                                return;
                            }
                            this.negotiationPending = true;
                            console.log('Negotiation needed, creating offer...');
                            try {
                                const offer = await this.peerConnection.createOffer();
                                await this.peerConnection.setLocalDescription(offer);
                                console.log('Local description (offer) set. Sending offer:', offer.sdp.substring(0, 100) + '...');
                                this.socket.emit('offer', { sdp: this.peerConnection.localDescription });
                                this.negotiationPending = false;
                            } catch (err) {
                                console.error('Error during negotiationneeded:', err);
                                this.error = 'Failed to negotiate video call.';
                                this.negotiationPending = false;
                            }
                        };

                        this.peerConnection.oniceconnectionstatechange = () => {
                            console.log('ICE Connection state:', this.peerConnection.iceConnectionState);
                            if (['disconnected', 'failed', 'closed'].includes(this.peerConnection.iceConnectionState)) {
                                this.partnerWebcamActive = false;
                                if (this.peerConnection.iceConnectionState === 'failed') {
                                    console.warn('WebRTC ICE connection failed.');
                                    this.peerConnection.restartIce();
                                }
                            }
                        };

                        this.peerConnection.onconnectionstatechange = () => {
                            console.log('Connection state:', this.peerConnection.connectionState);
                            if (this.peerConnection.connectionState === 'failed') {
                                this.error = 'WebRTC connection failed. Try restarting webcam.';
                                this.partnerWebcamActive = false;
                            } else if (this.peerConnection.connectionState === 'connected') {
                                console.log('WebRTC connection established successfully.');
                                this.error = '';
                            }
                        };

                        this.peerConnection.onsignalingstatechange = () => {
                            console.log('Signaling state:', this.peerConnection.signalingState);
                        };

                    } catch (err) {
                        console.error("Error creating Peer Connection:", err);
                        this.error = "Failed to initialize video connection.";
                    }
                },

                async createOffer() {
                    if (!this.peerConnection) {
                        console.warn('Cannot create offer: No peer connection exists.');
                        return;
                    }
                    if (this.negotiationPending) {
                        console.log('Negotiation already pending, queuing...');
                        return;
                    }
                    this.negotiationPending = true;
                    console.log('Creating offer...');
                    try {
                        const offer = await this.peerConnection.createOffer();
                        await this.peerConnection.setLocalDescription(offer);
                        console.log('Local description (offer) set. Sending offer:', offer.sdp.substring(0, 100) + '...');
                        this.socket.emit('offer', { sdp: this.peerConnection.localDescription });
                        this.negotiationPending = false;
                    } catch (err) {
                        console.error('Error creating or setting offer:', err);
                        this.error = 'Failed to initiate video call.';
                        this.negotiationPending = false;
                    }
                },

                updateGameState(gameState) {
                    if (!gameState) {
                        console.warn("Received null/undefined gameState update.");
                        return;
                    }
                    console.log('Updating game state with:', JSON.stringify(gameState));
                    this.gameType = gameState.gameType;
                    const newChallenge = this.formatChallenge(gameState.currentChallenge);
                    this.currentChallenge = newChallenge;

                    if (gameState.gameOver) {
                        this.turnStatus = "Game Over";
                        this.isMyTurn = false;
                    } else if (gameState.turn === this.playerNumber) {
                        this.isMyTurn = true;
                        this.turnStatus = "üíñ Your Turn! üíñ";
                        this.partnerStatus = '';
                    } else {
                        this.isMyTurn = false;
                        this.turnStatus = gameState.currentChallenge ? "Partner's Turn... ü§î" : 'Waiting...';
                    }

                    this.actionInProgress = false;
                    if (this.status.includes('Joining') || this.status.includes('Connected') || this.status.includes('Reconnected')) {
                        this.status = '';
                    }
                },

                formatChallenge(text) {
                    if (!text || text === "Loading first challenge...") {
                        if (this.playerNumber && this.gameType && this.turnStatus !== 'Initializing...') {
                            return 'Waiting for challenge...';
                        } else {
                            return 'Waiting for the game to start...';
                        }
                    }
                    let escaped = text.replace(/</g, '<').replace(/>/g, '>');
                    escaped = escaped.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    return escaped.replace(/\n/g, '<br>');
                },

                triggerFadeIn() {
                    this.$nextTick(() => {
                        const el = document.getElementById('challenge-text');
                        if (el) {
                            el.classList.remove('fade-in');
                            void el.offsetWidth;
                            el.classList.add('fade-in');
                        }
                    });
                },

                async toggleWebcam() {
                    if (this.webcamActive) {
                        this.stopWebcam();
                    } else {
                        await this.startWebcam();
                    }
                },

                async startWebcam() {
                    console.log("Attempting to start webcam...");
                    if (this.webcamActive) {
                        console.warn("Webcam already active.");
                        return;
                    }
                    try {
                        this.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                        const localVideo = document.getElementById('localVideo');
                        localVideo.srcObject = this.localStream;
                        this.webcamActive = true;
                        this.textAnswer = '';
                        console.log("Local stream acquired.");

                        const videoTracks = this.localStream.getVideoTracks();
                        const audioTracks = this.localStream.getAudioTracks();
                        console.log('Local video tracks:', videoTracks.map(t => ({ id: t.id, enabled: t.enabled, muted: t.muted })));
                        console.log('Local audio tracks:', audioTracks.map(t => ({ id: t.id, enabled: t.enabled, muted: t.muted })));
                        if (audioTracks.length === 0) {
                            console.warn('No audio tracks available. Microphone may be disabled or permissions denied.');
                            this.error = 'Microphone access is required for audio. Please enable it in your browser settings.';
                        }

                        if (!this.peerConnection) {
                            this.initPeerConnection();
                        }

                        if (this.peerConnection) {
                            const existingSenders = this.peerConnection.getSenders().map(sender => sender.track?.id);
                            this.localTrackSenders = [];
                            this.localStream.getTracks().forEach(track => {
                                if (!existingSenders.includes(track.id)) {
                                    try {
                                        track.enabled = true;
                                        this.localTrackSenders.push(this.peerConnection.addTrack(track, this.localStream));
                                        console.log('Added local track:', track.kind, 'enabled:', track.enabled, 'muted:', track.muted);
                                    } catch (err) {
                                        console.error('Error adding track:', err);
                                    }
                                } else {
                                    console.log('Skipped adding track; sender already exists for track ID:', track.id);
                                }
                            });
                        } else {
                            console.error("PeerConnection not initialized!");
                            this.error = "Failed to setup video connection.";
                            this.stopWebcam();
                            return;
                        }

                        this.socket.emit('webcamStatus', { active: true });

                        console.log("Webcam started, waiting for negotiation.");

                    } catch (err) {
                        console.error("Error accessing webcam/WebRTC:", err);
                        this.error = `Could not access webcam or microphone (${err.name}). Please check permissions.`;
                        this.webcamActive = false;
                        this.localStream = null;
                        if (this.peerConnection && !this.localTrackSenders.length) {
                            this.peerConnection.close();
                            this.peerConnection = null;
                        }
                    }
                },

                stopWebcam() {
                    console.log("Stopping webcam...");
                    if (this.localStream) {
                        this.localStream.getTracks().forEach(track => track.stop());
                        this.localStream = null;
                        const localVideo = document.getElementById('localVideo');
                        if (localVideo) localVideo.srcObject = null;
                        console.log("Local stream tracks stopped.");
                    }

                    if (this.webcamActive) {
                        this.webcamActive = false;
                        this.socket.emit('webcamStatus', { active: false });
                    }

                    if (this.peerConnection && this.localTrackSenders.length) {
                        this.localTrackSenders.forEach(sender => {
                            try {
                                this.peerConnection.removeTrack(sender);
                                console.log('Removed local track sender.');
                            } catch (err) {
                                console.error('Error removing track sender:', err);
                            }
                        });
                        this.localTrackSenders = [];
                    }

                    console.log("Webcam stopped, peer connection preserved for remote stream.");
                },

                performAction() {
                    if (!this.isMyTurn || this.actionInProgress) return;
                    this.actionInProgress = true;
                    this.status = '';
                    this.error = '';
                    this.partnerStatus = '';

                    if (!this.webcamActive && this.textAnswer.trim()) {
                        console.log('Sending text answer:', this.textAnswer);
                        this.socket.emit('sendTextAnswer', this.textAnswer);
                    } else if (this.webcamActive) {
                        console.log('Completing turn (webcam was active).');
                    } else {
                        console.log('Completing turn (no text answer).');
                    }

                    console.log('Emitting completeTurn');
                    this.socket.emit('completeTurn');

                    this.isMyTurn = false;
                    this.turnStatus = "Waiting for next challenge...";
                    this.textAnswer = '';
                    this.receivedTextAnswer = '';
                    this.receivedReaction = '';
                },

                sendReaction(reaction) {
                    console.log('Sending reaction:', reaction);
                    this.socket.emit('sendReaction', reaction);
                    this.receivedTextAnswer = '';
                    this.partnerStatus = 'Waiting for partner to complete their turn...';
                },
            }
        }
    </script>
</body>
</html>